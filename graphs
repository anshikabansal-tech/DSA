#include <bits/stdc++.h>
using namespace std;

class Graph {
public:
    int V;
    vector<vector<pair<int,int>>> adj;

    Graph(int V) {
        this->V = V;
        adj.resize(V);
    }

    void addEdge(int u, int v, int w = 1, bool bidir = true) {
        adj[u].push_back({v, w});
        if (bidir)
            adj[v].push_back({u, w});
    }

    void BFS(int start) {
        vector<bool> visited(V, false);
        queue<int> q;
        visited[start] = true;
        q.push(start);
        cout << "BFS Traversal: ";
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            cout << u << " ";
            for (auto &x : adj[u]) {
                if (!visited[x.first]) {
                    visited[x.first] = true;
                    q.push(x.first);
                }
            }
        }
        cout << endl;
    }

    void DFSUtil(int u, vector<bool> &visited) {
        visited[u] = true;
        cout << u << " ";
        for (auto &x : adj[u]) {
            if (!visited[x.first])
                DFSUtil(x.first, visited);
        }
    }

    void DFS(int start) {
        vector<bool> visited(V, false);
        cout << "DFS Traversal: ";
        DFSUtil(start, visited);
        cout << endl;
    }

    void primMST(int start = 0) {
        vector<int> key(V, INT_MAX);
        vector<bool> inMST(V, false);
        vector<int> parent(V, -1);
        key[start] = 0;
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        pq.push({0, start});

        while (!pq.empty()) {
            int u = pq.top().second;
            pq.pop();
            inMST[u] = true;
            for (auto &x : adj[u]) {
                int v = x.first, w = x.second;
                if (!inMST[v] && w < key[v]) {
                    parent[v] = u;
                    key[v] = w;
                    pq.push({key[v], v});
                }
            }
        }

        cout << "Prim's MST Edges:\n";
        for (int i = 1; i < V; i++) {
            cout << parent[i] << " - " << i << endl;
        }
    }

    class DSU {
    public:
        vector<int> parent, rank;
        DSU(int n) {
            parent.resize(n);
            rank.resize(n, 0);
            for (int i = 0; i < n; i++)
                parent[i] = i;
        }
        int find(int x) {
            if (x != parent[x])
                parent[x] = find(parent[x]);
            return parent[x];
        }
        void unite(int x, int y) {
            x = find(x);
            y = find(y);
            if (rank[x] < rank[y]) swap(x, y);
            parent[y] = x;
            if (rank[x] == rank[y]) rank[x]++;
        }
    };

    void KruskalMST() {
        vector<pair<int, pair<int,int>>> edges;
        for (int u = 0; u < V; u++) {
            for (auto &x : adj[u]) {
                edges.push_back({x.second, {u, x.first}});
            }
        }
        sort(edges.begin(), edges.end());

        DSU dsu(V);
        cout << "Kruskal's MST Edges:\n";
        int total = 0;

        for (auto &e : edges) {
            int w = e.first;
            int u = e.second.first;
            int v = e.second.second;
            if (dsu.find(u) != dsu.find(v)) {
                cout << u << " - " << v << " (Weight: " << w << ")\n";
                total += w;
                dsu.unite(u, v);
            }
        }
        cout << "Total Weight = " << total << endl;
    }

    void Dijkstra(int src) {
        vector<int> dist(V, INT_MAX);
        dist[src] = 0;
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        pq.push({0, src});

        while (!pq.empty()) {
            int u = pq.top().second;
            pq.pop();
            for (auto &x : adj[u]) {
                int v = x.first, w = x.second;
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    pq.push({dist[v], v});
                }
            }
        }

        cout << "Dijkstra Shortest Distances:\n";
        for (int i = 0; i < V; i++)
            cout << "Node " << i << " Distance: " << dist[i] << endl;
    }
};

int main() {
    int V, E;
    cout << "Enter vertices and edges: ";
    cin >> V >> E;

    Graph g(V);

    cout << "Enter edges (u v w):\n";
    for (int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g.addEdge(u, v, w);
    }

    cout << "\n--- BFS ---\n";
    g.BFS(0);

    cout << "\n--- DFS ---\n";
    g.DFS(0);

    cout << "\n--- Prim's Minimum Spanning Tree ---\n";
    g.primMST();

    cout << "\n--- Kruskal's Minimum Spanning Tree ---\n";
    g.KruskalMST();

    cout << "\n--- Dijkstra Shortest Path ---\n";
    g.Dijkstra(0);

    return 0;
}
